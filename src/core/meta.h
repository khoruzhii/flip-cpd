// meta.h
// Tensor metadata loader for tensors generated by scripts/generator.py
#pragma once

#include <string>
#include <optional>
#include <filesystem>
#include <fstream>
#include <stdexcept>

#include "picojson.h"

struct TensorMeta {
    std::string name;
    int nU = 0;
    int nV = 0;
    int nW = 0;

    std::optional<std::string> op;
    std::optional<int> n1;
    std::optional<int> n2;
    std::optional<int> n3;
};

inline TensorMeta load_tensor_meta(const std::filesystem::path& meta_path) {
    TensorMeta meta;

    std::ifstream is(meta_path);
    if (!is) {
        throw std::runtime_error("load_tensor_meta: cannot open file " + meta_path.string());
    }

    picojson::value v;
    is >> v;
    std::string err = picojson::get_last_error();
    if (!err.empty()) {
        throw std::runtime_error("load_tensor_meta: parse error in " + meta_path.string() + ": " + err);
    }

    if (!v.is<picojson::object>()) {
        throw std::runtime_error("load_tensor_meta: root is not an object in " + meta_path.string());
    }

    const picojson::object& obj = v.get<picojson::object>();

    auto get_required = [&](const char* key) -> const picojson::value& {
        auto it = obj.find(key);
        if (it == obj.end()) {
            throw std::runtime_error(
                std::string("load_tensor_meta: missing required key '") + key +
                "' in " + meta_path.string()
            );
        }
        return it->second;
    };

    // name
    {
        const picojson::value& name_v = get_required("name");
        if (!name_v.is<std::string>()) {
            throw std::runtime_error("load_tensor_meta: 'name' must be a string in " + meta_path.string());
        }
        meta.name = name_v.get<std::string>();
    }

    // nU, nV, nW
    {
        const picojson::value& nU_v = get_required("nU");
        const picojson::value& nV_v = get_required("nV");
        const picojson::value& nW_v = get_required("nW");

        if (!nU_v.is<double>() || !nV_v.is<double>() || !nW_v.is<double>()) {
            throw std::runtime_error(
                "load_tensor_meta: 'nU', 'nV', 'nW' must be numbers in " + meta_path.string()
            );
        }

        meta.nU = static_cast<int>(nU_v.get<double>());
        meta.nV = static_cast<int>(nV_v.get<double>());
        meta.nW = static_cast<int>(nW_v.get<double>());
    }

    auto load_optional_int = [&](const char* key, std::optional<int>& dst) {
        auto it = obj.find(key);
        if (it == obj.end()) {
            return;
        }
        const picojson::value& val = it->second;
        if (val.is<picojson::null>()) {
            return;
        }
        if (!val.is<double>()) {
            throw std::runtime_error(
                std::string("load_tensor_meta: '") + key +
                "' must be a number or null in " + meta_path.string()
            );
        }
        dst = static_cast<int>(val.get<double>());
    };

    auto load_optional_string = [&](const char* key, std::optional<std::string>& dst) {
        auto it = obj.find(key);
        if (it == obj.end()) {
            return;
        }
        const picojson::value& val = it->second;
        if (val.is<picojson::null>()) {
            return;
        }
        if (!val.is<std::string>()) {
            throw std::runtime_error(
                std::string("load_tensor_meta: '") + key +
                "' must be a string or null in " + meta_path.string()
            );
        }
        dst = val.get<std::string>();
    };

    load_optional_string("op", meta.op);
    load_optional_int("n1", meta.n1);
    load_optional_int("n2", meta.n2);
    load_optional_int("n3", meta.n3);

    return meta;
}
